/*
    ОТЧЕТ https://contest.yandex.ru/contest/23815/run-report/89958697/
    
    Пусть n - длина входного массива.

    -- ПРИНЦИП РАБОТЫ --
    Используем бинарный поиск. Поиск происходит на отрезке [left, right) - правый элемент не включается.
    1. Сравниваем искомый элемент с центральным. Если не совпали, продолжаем поиск.
    2. Центральный элемент делит массив на 2 половины. В одной из половин будет находится разрыв, а другая половина будет отсортирована. Если левый элемент меньше центрального, значит отсортирована левая половина, а разрыв находится в правой половине. Иначе наоборот.
    3. Определив, какая из половин отсортирована, проверяем находится ли искомый элемент в отсортированной половине. Если да, продолжаем поиск в этой половине. Иначе ищем в другой половине.

    -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Сложность = O(log(n)).
    Временная сложность бинарного поиска O(log(n)). На каждой итерации мы делим рассматриваемый отрезок пополам и продолжаем поиск в одной из половин.

    -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Сложность = 1 * log(n) = O(log(n)).
    Пространственная сложность определяется глубиной рекурсии и количеством необходимой дополнительной памяти на каждом рекурсивном вызове:
    – Каждый рекурсивный вызов функции расходует константную дополнительную память O(1). 
    – Глубина рекурсии равна количеству рекурсивных вызовов функции и равна временной сложности алгоритма – O(log(n)). 
    Итого: 1 * log(n) = O(log(n)).
*/

function brokenSearch(arr, k) {
  return binarySearch(arr, k, 0, arr.length);
}

function binarySearch(arr, x, left, right) {
  if (right <= left) { // промежуток пуст
    return -1;
  }
  // промежуток не пуст
  const mid = Math.floor((left + right) / 2);
  if (arr[mid] === x) { // центральный элемент — искомый
    return mid;
  } else if (arr[left] < arr[mid]) { // левая половина отсортирована
    if (arr[left] <= x && x < arr[mid]) { // искомый элемент в левой половине
      right = mid; // продолжаем поиск в левой половине
    } else { // искомый элемент в правой половине
      left = mid + 1; // продолжаем поиск в правой половине (не в ключая центральный элемент, его уже проверили)
    }
  } else { // правая половина отсортирована
    if (arr[mid] < x && x <= arr[right - 1]) { // искомый элемент в правой половине
      left = mid + 1; // продолжаем поиск в правой половине (не включая центральный элемент, его уже проверили)
    } else { // искомый элемент в левой половине
      right = mid; // продолжаем поиск в левой половине
    }
  }

  return binarySearch(arr, x, left, right);
}

function test() {
    const arr = [19, 21, 100, 101, 1, 4, 5, 7, 12];
    if (brokenSearch(arr, 5) !== 6)  {
        console.error("WA");
    }
}